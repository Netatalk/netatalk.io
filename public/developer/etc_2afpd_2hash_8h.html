<!-- HTML header for doxygen 1.14.0-->
<!-- modified for netatalk -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>netatalk: hash.h File Reference</title>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<script
    src="https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js"
    integrity="o+g/BxPwhi0C3RK7oQBxQuNimeafQ3GE/ST4iT2BxVI4Wzt60SH4pq9iXVYujjaS"
    crossorigin="anonymous"
></script>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectrow">
    <div id="projectlogo">
      <a href="/"><img alt="Logo" src="logo.png"/></a>
    </div>
    <div id="projectalign">
      <div id="projectname">
        netatalk
        <span id="projectnumber">&#160;4.4.0dev</span>
      </div>
      <div id="projectbrief">Free and Open Source Apple Filing Protocol (AFP) Server</div>
    </div>
  </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('etc_2afpd_2hash_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">hash.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;<a class="el" href="include_2atalk_2hash_8h_source.html">atalk/hash.h</a>&gt;</code><br />
</div>
<p><a href="etc_2afpd_2hash_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:abb2fc3909c1b755c2eebbfca70b75224" id="r_abb2fc3909c1b755c2eebbfca70b75224"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb2fc3909c1b755c2eebbfca70b75224">hash_isfull</a>(H)</td></tr>
<tr class="memitem:abf29c36234f69befc1482288d285e9f4" id="r_abf29c36234f69befc1482288d285e9f4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf29c36234f69befc1482288d285e9f4">hash_isempty</a>(H)</td></tr>
<tr class="memitem:aee51edace4f8d05308de177b37c5b7d2" id="r_aee51edace4f8d05308de177b37c5b7d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee51edace4f8d05308de177b37c5b7d2">hash_count</a>(H)</td></tr>
<tr class="memitem:ad661839caf283bc7547a06c91c69f801" id="r_ad661839caf283bc7547a06c91c69f801"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad661839caf283bc7547a06c91c69f801">hash_size</a>(H)</td></tr>
<tr class="memitem:a3e300f7336e60fce5689f23cdd978ace" id="r_a3e300f7336e60fce5689f23cdd978ace"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e300f7336e60fce5689f23cdd978ace">hnode_get</a>(N)</td></tr>
<tr class="memitem:a19b286e0c6af11d53f94af89db94b096" id="r_a19b286e0c6af11d53f94af89db94b096"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19b286e0c6af11d53f94af89db94b096">hnode_getkey</a>(N)</td></tr>
<tr class="memitem:a77f3364d12b67ee9c799a8ef57315555" id="r_a77f3364d12b67ee9c799a8ef57315555"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77f3364d12b67ee9c799a8ef57315555">hnode_put</a>(N,  V)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8c7030ef7b7cd5bb3a48e1f2cc5ae94d" id="r_a8c7030ef7b7cd5bb3a48e1f2cc5ae94d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhash__t.html">hash_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c7030ef7b7cd5bb3a48e1f2cc5ae94d">hash_create</a> (<a class="el" href="include_2atalk_2hash_8h.html#aecc5473199dcc266fd5174f30f64a580">hashcount_t</a>, <a class="el" href="include_2atalk_2hash_8h.html#a29451e8034bdfff2913f59e4c1e5a880">hash_comp_t</a>, <a class="el" href="include_2atalk_2hash_8h.html#a00ebf8a3e3c5692149bb2b90f37d7c5b">hash_fun_t</a>)</td></tr>
<tr class="memdesc:a8c7030ef7b7cd5bb3a48e1f2cc5ae94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dynamic hash table.  <br /></td></tr>
<tr class="memitem:a1203f51c651d3399b5e18876a4e7a1d1" id="r_a1203f51c651d3399b5e18876a4e7a1d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1203f51c651d3399b5e18876a4e7a1d1">hash_set_allocator</a> (<a class="el" href="structhash__t.html">hash_t</a> *, <a class="el" href="include_2atalk_2hash_8h.html#aa15898e7f6a029e6d8f7aca3e93efe09">hnode_alloc_t</a>, <a class="el" href="include_2atalk_2hash_8h.html#a8adb2eee3d269765dafe4d132d1508ae">hnode_free_t</a>, void *)</td></tr>
<tr class="memitem:ac2f256f9c40ad317da05b01fa70c32ca" id="r_ac2f256f9c40ad317da05b01fa70c32ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2f256f9c40ad317da05b01fa70c32ca">hash_destroy</a> (<a class="el" href="structhash__t.html">hash_t</a> *)</td></tr>
<tr class="memitem:a6de1a2c9caf587602ac0d7591bad1de0" id="r_a6de1a2c9caf587602ac0d7591bad1de0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6de1a2c9caf587602ac0d7591bad1de0">hash_free_nodes</a> (<a class="el" href="structhash__t.html">hash_t</a> *)</td></tr>
<tr class="memitem:aeeb1b514da9839270632757f6eb60fe5" id="r_aeeb1b514da9839270632757f6eb60fe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeeb1b514da9839270632757f6eb60fe5">hash_free</a> (<a class="el" href="structhash__t.html">hash_t</a> *)</td></tr>
<tr class="memitem:a6064585d780b6c320f4342c917b1380f" id="r_a6064585d780b6c320f4342c917b1380f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhash__t.html">hash_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6064585d780b6c320f4342c917b1380f">hash_init</a> (<a class="el" href="structhash__t.html">hash_t</a> *, <a class="el" href="include_2atalk_2hash_8h.html#aecc5473199dcc266fd5174f30f64a580">hashcount_t</a>, <a class="el" href="include_2atalk_2hash_8h.html#a29451e8034bdfff2913f59e4c1e5a880">hash_comp_t</a>, <a class="el" href="include_2atalk_2hash_8h.html#a00ebf8a3e3c5692149bb2b90f37d7c5b">hash_fun_t</a>, <a class="el" href="structhnode__t.html">hnode_t</a> **, <a class="el" href="include_2atalk_2hash_8h.html#aecc5473199dcc266fd5174f30f64a580">hashcount_t</a>)</td></tr>
<tr class="memitem:a112c186be0920dcd690f1d79e2305e95" id="r_a112c186be0920dcd690f1d79e2305e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a112c186be0920dcd690f1d79e2305e95">hash_insert</a> (<a class="el" href="structhash__t.html">hash_t</a> *, <a class="el" href="structhnode__t.html">hnode_t</a> *, const void *)</td></tr>
<tr class="memdesc:a112c186be0920dcd690f1d79e2305e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a node into the hash table.  <br /></td></tr>
<tr class="memitem:a9354a987c0ba20adfbcd84272fd7b4a8" id="r_a9354a987c0ba20adfbcd84272fd7b4a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhnode__t.html">hnode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9354a987c0ba20adfbcd84272fd7b4a8">hash_lookup</a> (<a class="el" href="structhash__t.html">hash_t</a> *, const void *)</td></tr>
<tr class="memdesc:a9354a987c0ba20adfbcd84272fd7b4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node in the hash table and return a pointer to it.  <br /></td></tr>
<tr class="memitem:ab26ac24a40a6220349ffc758610e79ac" id="r_ab26ac24a40a6220349ffc758610e79ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhnode__t.html">hnode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab26ac24a40a6220349ffc758610e79ac">hash_delete</a> (<a class="el" href="structhash__t.html">hash_t</a> *, <a class="el" href="structhnode__t.html">hnode_t</a> *)</td></tr>
<tr class="memdesc:ab26ac24a40a6220349ffc758610e79ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the given node from the hash table. Since the chains are singly linked, we must locate the start of the node's chain and traverse.  <br /></td></tr>
<tr class="memitem:a5237a137033fe258927fe9349b79e8a1" id="r_a5237a137033fe258927fe9349b79e8a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5237a137033fe258927fe9349b79e8a1">hash_alloc_insert</a> (<a class="el" href="structhash__t.html">hash_t</a> *, const void *, void *)</td></tr>
<tr class="memitem:a39f6c09e45e5e2d6d69117aa52ce7587" id="r_a39f6c09e45e5e2d6d69117aa52ce7587"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39f6c09e45e5e2d6d69117aa52ce7587">hash_delete_free</a> (<a class="el" href="structhash__t.html">hash_t</a> *, <a class="el" href="structhnode__t.html">hnode_t</a> *)</td></tr>
<tr class="memitem:ae4a1492b158a319cc1849e1ef8a816b4" id="r_ae4a1492b158a319cc1849e1ef8a816b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4a1492b158a319cc1849e1ef8a816b4">hnode_put</a> (<a class="el" href="structhnode__t.html">hnode_t</a> *, void *)</td></tr>
<tr class="memitem:a690258e79608f3ff1799f0676c4b4395" id="r_a690258e79608f3ff1799f0676c4b4395"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a690258e79608f3ff1799f0676c4b4395">hnode_get</a> (<a class="el" href="structhnode__t.html">hnode_t</a> *)</td></tr>
<tr class="memitem:a65e3d96131650bbd7770fc9c6147cf12" id="r_a65e3d96131650bbd7770fc9c6147cf12"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65e3d96131650bbd7770fc9c6147cf12">hnode_getkey</a> (<a class="el" href="structhnode__t.html">hnode_t</a> *)</td></tr>
<tr class="memitem:aecbaae817e8fa1b0c6ae5dedc6ac8164" id="r_aecbaae817e8fa1b0c6ae5dedc6ac8164"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2atalk_2hash_8h.html#aecc5473199dcc266fd5174f30f64a580">hashcount_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecbaae817e8fa1b0c6ae5dedc6ac8164">hash_count</a> (<a class="el" href="structhash__t.html">hash_t</a> *)</td></tr>
<tr class="memitem:a18b46dffd48fa70bf6a6a107988720cb" id="r_a18b46dffd48fa70bf6a6a107988720cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2atalk_2hash_8h.html#aecc5473199dcc266fd5174f30f64a580">hashcount_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18b46dffd48fa70bf6a6a107988720cb">hash_size</a> (<a class="el" href="structhash__t.html">hash_t</a> *)</td></tr>
<tr class="memitem:a4b7bdd46a67b604ecce90ebb2db571c8" id="r_a4b7bdd46a67b604ecce90ebb2db571c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b7bdd46a67b604ecce90ebb2db571c8">hash_isfull</a> (<a class="el" href="structhash__t.html">hash_t</a> *)</td></tr>
<tr class="memitem:a33fce57bb9ece849cf349e324b10a084" id="r_a33fce57bb9ece849cf349e324b10a084"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33fce57bb9ece849cf349e324b10a084">hash_isempty</a> (<a class="el" href="structhash__t.html">hash_t</a> *)</td></tr>
<tr class="memitem:ad5fda68973485a56ae372c40238d0f30" id="r_ad5fda68973485a56ae372c40238d0f30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5fda68973485a56ae372c40238d0f30">hash_scan_begin</a> (<a class="el" href="structhscan__t.html">hscan_t</a> *, <a class="el" href="structhash__t.html">hash_t</a> *)</td></tr>
<tr class="memdesc:ad5fda68973485a56ae372c40238d0f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a hash scanner.  <br /></td></tr>
<tr class="memitem:ad4bb2a56407807bb7a0fff4d90c13d47" id="r_ad4bb2a56407807bb7a0fff4d90c13d47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhnode__t.html">hnode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4bb2a56407807bb7a0fff4d90c13d47">hash_scan_next</a> (<a class="el" href="structhscan__t.html">hscan_t</a> *)</td></tr>
<tr class="memdesc:ad4bb2a56407807bb7a0fff4d90c13d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the next node from the hash table, and update the pointer for the next invocation of <a class="el" href="hash_8c.html#a71535648d50cdb2b93d1d47eeb4fb872" title="Retrieve the next node from the hash table, and update the pointer for the next invocation of hash_sc...">hash_scan_next()</a>.  <br /></td></tr>
<tr class="memitem:a8bdfb6df29d592b81e39b5b1703c3c58" id="r_a8bdfb6df29d592b81e39b5b1703c3c58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhnode__t.html">hnode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bdfb6df29d592b81e39b5b1703c3c58">hash_scan_delete</a> (<a class="el" href="structhash__t.html">hash_t</a> *, <a class="el" href="structhnode__t.html">hnode_t</a> *)</td></tr>
<tr class="memitem:a2e40134f24f3037e73368f7e3b78083e" id="r_a2e40134f24f3037e73368f7e3b78083e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e40134f24f3037e73368f7e3b78083e">hash_scan_delfree</a> (<a class="el" href="structhash__t.html">hash_t</a> *, <a class="el" href="structhnode__t.html">hnode_t</a> *)</td></tr>
<tr class="memitem:a3d2a68020dd6bd10ea5ba593f747d22e" id="r_a3d2a68020dd6bd10ea5ba593f747d22e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d2a68020dd6bd10ea5ba593f747d22e">hash_verify</a> (<a class="el" href="structhash__t.html">hash_t</a> *)</td></tr>
<tr class="memdesc:a3d2a68020dd6bd10ea5ba593f747d22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify whether the given object is a valid hash table.  <br /></td></tr>
<tr class="memitem:a9d481e3f3a6590f5b8024f1651aaade9" id="r_a9d481e3f3a6590f5b8024f1651aaade9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhnode__t.html">hnode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d481e3f3a6590f5b8024f1651aaade9">hnode_create</a> (void *)</td></tr>
<tr class="memitem:aaafa54bec0810daa790e9c675b667bec" id="r_aaafa54bec0810daa790e9c675b667bec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhnode__t.html">hnode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaafa54bec0810daa790e9c675b667bec">hnode_init</a> (<a class="el" href="structhnode__t.html">hnode_t</a> *, void *)</td></tr>
<tr class="memitem:ab12306327a8f919b8a3c1747795f1197" id="r_ab12306327a8f919b8a3c1747795f1197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab12306327a8f919b8a3c1747795f1197">hnode_destroy</a> (<a class="el" href="structhnode__t.html">hnode_t</a> *)</td></tr>
</table>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="aee51edace4f8d05308de177b37c5b7d2" name="aee51edace4f8d05308de177b37c5b7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee51edace4f8d05308de177b37c5b7d2">&#9670;&#160;</a></span>hash_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_count</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>H</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((H)-&gt;hash_nodecount)</div>
</div><!-- fragment -->
</div>
</div>
<a id="abf29c36234f69befc1482288d285e9f4" name="abf29c36234f69befc1482288d285e9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf29c36234f69befc1482288d285e9f4">&#9670;&#160;</a></span>hash_isempty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_isempty</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>H</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((H)-&gt;hash_nodecount == 0)</div>
</div><!-- fragment -->
</div>
</div>
<a id="abb2fc3909c1b755c2eebbfca70b75224" name="abb2fc3909c1b755c2eebbfca70b75224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2fc3909c1b755c2eebbfca70b75224">&#9670;&#160;</a></span>hash_isfull</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_isfull</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>H</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((H)-&gt;hash_nodecount == (H)-&gt;hash_maxcount)</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad661839caf283bc7547a06c91c69f801" name="ad661839caf283bc7547a06c91c69f801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad661839caf283bc7547a06c91c69f801">&#9670;&#160;</a></span>hash_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hash_size</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>H</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((H)-&gt;hash_nchains)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3e300f7336e60fce5689f23cdd978ace" name="a3e300f7336e60fce5689f23cdd978ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e300f7336e60fce5689f23cdd978ace">&#9670;&#160;</a></span>hnode_get</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hnode_get</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((N)-&gt;hash_data)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a19b286e0c6af11d53f94af89db94b096" name="a19b286e0c6af11d53f94af89db94b096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b286e0c6af11d53f94af89db94b096">&#9670;&#160;</a></span>hnode_getkey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hnode_getkey</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((N)-&gt;hash_key)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a77f3364d12b67ee9c799a8ef57315555" name="a77f3364d12b67ee9c799a8ef57315555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77f3364d12b67ee9c799a8ef57315555">&#9670;&#160;</a></span>hnode_put</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define hnode_put</td>
          <td>(</td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"></td>          <td class="paramname"><span class="paramname"><em>V</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((N)-&gt;hash_data = (V))</div>
</div><!-- fragment -->
</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a5237a137033fe258927fe9349b79e8a1" name="a5237a137033fe258927fe9349b79e8a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5237a137033fe258927fe9349b79e8a1">&#9670;&#160;</a></span>hash_alloc_insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hash_alloc_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aecbaae817e8fa1b0c6ae5dedc6ac8164" name="aecbaae817e8fa1b0c6ae5dedc6ac8164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbaae817e8fa1b0c6ae5dedc6ac8164">&#9670;&#160;</a></span>hash_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2atalk_2hash_8h.html#aecc5473199dcc266fd5174f30f64a580">hashcount_t</a> hash_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c7030ef7b7cd5bb3a48e1f2cc5ae94d" name="a8c7030ef7b7cd5bb3a48e1f2cc5ae94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7030ef7b7cd5bb3a48e1f2cc5ae94d">&#9670;&#160;</a></span>hash_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhash__t.html">hash_t</a> * hash_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="include_2atalk_2hash_8h.html#aecc5473199dcc266fd5174f30f64a580">hashcount_t</a></td>          <td class="paramname"><span class="paramname"><em>maxcount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="include_2atalk_2hash_8h.html#a29451e8034bdfff2913f59e4c1e5a880">hash_comp_t</a></td>          <td class="paramname"><span class="paramname"><em>compfun</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="include_2atalk_2hash_8h.html#a00ebf8a3e3c5692149bb2b90f37d7c5b">hash_fun_t</a></td>          <td class="paramname"><span class="paramname"><em>hashfun</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a dynamic hash table. </p>
<p>Both the hash table structure and the table itself are dynamically allocated. Furthermore, the table is extendible in that it will automatically grow as its load factor increases beyond a certain threshold.</p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>If the number of bits in the <a class="el" href="include_2atalk_2hash_8h.html#ad05b97a5bdacb4cc1aaf4a6268de8b48">hash_val_t</a> type has not been computed yet, we do so here, because this is likely to be the first function that the user calls.</li>
<li>Allocate a hash table control structure.</li>
<li>If a hash table control structure is successfully allocated, we proceed to initialize it. Otherwise we return a null pointer.</li>
<li>We try to allocate the table of hash chains.</li>
<li>If we were able to allocate the hash chain table, we can finish initializing the hash structure and the table. Otherwise, we must backtrack by freeing the hash structure.</li>
<li>INIT_SIZE should be a power of two. The high and low marks are always set to be twice the table size and half the table size respectively. When the number of nodes in the table grows beyond the high size (beyond load factor 2), it will double in size to cut the load factor down to about about 1. If the table shrinks down to or beneath load factor 0.5, it will shrink, bringing the load up to about 1. However, the table will never shrink beneath INIT_SIZE even if it's emptied.</li>
<li>This indicates that the table is dynamically allocated and dynamically resized on the fly. A table that has this value set to zero is assumed to be statically allocated and will not be resized.</li>
<li>The table of chains must be properly reset to all null pointers. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="ab26ac24a40a6220349ffc758610e79ac" name="ab26ac24a40a6220349ffc758610e79ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26ac24a40a6220349ffc758610e79ac">&#9670;&#160;</a></span>hash_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhnode__t.html">hnode_t</a> * hash_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhnode__t.html">hnode_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the given node from the hash table. Since the chains are singly linked, we must locate the start of the node's chain and traverse. </p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>The node must belong to this hash table, and its key must not have been tampered with.</li>
<li>If this deletion will take the node count below the low mark, we shrink the table now.</li>
<li>Determine which chain the node belongs to, and fetch the pointer to the first node in this chain.</li>
<li>If the node being deleted is the first node in the chain, then simply update the chain head pointer.</li>
<li>Otherwise advance to the node's predecessor, and splice out by updating the predecessor's next pointer.</li>
<li>Indicate that the node is no longer in a hash table. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a39f6c09e45e5e2d6d69117aa52ce7587" name="a39f6c09e45e5e2d6d69117aa52ce7587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f6c09e45e5e2d6d69117aa52ce7587">&#9670;&#160;</a></span>hash_delete_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_delete_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhnode__t.html">hnode_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2f256f9c40ad317da05b01fa70c32ca" name="ac2f256f9c40ad317da05b01fa70c32ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f256f9c40ad317da05b01fa70c32ca">&#9670;&#160;</a></span>hash_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free a dynamic hash table structure. </p>

</div>
</div>
<a id="aeeb1b514da9839270632757f6eb60fe5" name="aeeb1b514da9839270632757f6eb60fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb1b514da9839270632757f6eb60fe5">&#9670;&#160;</a></span>hash_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6de1a2c9caf587602ac0d7591bad1de0" name="a6de1a2c9caf587602ac0d7591bad1de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de1a2c9caf587602ac0d7591bad1de0">&#9670;&#160;</a></span>hash_free_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_free_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free every node in the hash using the hash-&gt;<a class="el" href="hash_8c.html#a30440a97a3a6b753a35a4b55b474e828">freenode()</a> function pointer, and cause the hash to become empty. </p>

</div>
</div>
<a id="a6064585d780b6c320f4342c917b1380f" name="a6064585d780b6c320f4342c917b1380f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6064585d780b6c320f4342c917b1380f">&#9670;&#160;</a></span>hash_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhash__t.html">hash_t</a> * hash_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="include_2atalk_2hash_8h.html#aecc5473199dcc266fd5174f30f64a580">hashcount_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="include_2atalk_2hash_8h.html#a29451e8034bdfff2913f59e4c1e5a880">hash_comp_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="include_2atalk_2hash_8h.html#a00ebf8a3e3c5692149bb2b90f37d7c5b">hash_fun_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhnode__t.html">hnode_t</a> **</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="include_2atalk_2hash_8h.html#aecc5473199dcc266fd5174f30f64a580">hashcount_t</a></td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a112c186be0920dcd690f1d79e2305e95" name="a112c186be0920dcd690f1d79e2305e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112c186be0920dcd690f1d79e2305e95">&#9670;&#160;</a></span>hash_insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhnode__t.html">hnode_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a node into the hash table. </p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>It's illegal to insert more than the maximum number of nodes. The client should verify that the hash table is not full before attempting an insertion.</li>
<li>The same key may not be inserted into a table twice.</li>
<li>If the table is dynamic and the load factor is already at &gt;= 2, grow the table.</li>
<li>We take the bottom N bits of the hash value to derive the chain index, where N is the base 2 logarithm of the size of the hash table. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a33fce57bb9ece849cf349e324b10a084" name="a33fce57bb9ece849cf349e324b10a084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33fce57bb9ece849cf349e324b10a084">&#9670;&#160;</a></span>hash_isempty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hash_isempty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b7bdd46a67b604ecce90ebb2db571c8" name="a4b7bdd46a67b604ecce90ebb2db571c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7bdd46a67b604ecce90ebb2db571c8">&#9670;&#160;</a></span>hash_isfull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hash_isfull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9354a987c0ba20adfbcd84272fd7b4a8" name="a9354a987c0ba20adfbcd84272fd7b4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9354a987c0ba20adfbcd84272fd7b4a8">&#9670;&#160;</a></span>hash_lookup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhnode__t.html">hnode_t</a> * hash_lookup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>key</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find a node in the hash table and return a pointer to it. </p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>We hash the key and keep the entire hash value. As an optimization, when we descend down the chain, we can compare hash values first and only if hash values match do we perform a full key comparison.</li>
<li>To locate the chain from among 2^N chains, we look at the lower N bits of the hash value by anding them with the current mask.</li>
<li>Looping through the chain, we compare the stored hash value inside each node against our computed hash. If they match, then we do a full comparison between the unhashed keys. If these match, we have located the entry. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="ad5fda68973485a56ae372c40238d0f30" name="ad5fda68973485a56ae372c40238d0f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fda68973485a56ae372c40238d0f30">&#9670;&#160;</a></span>hash_scan_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_scan_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhscan__t.html">hscan_t</a> *</td>          <td class="paramname"><span class="paramname"><em>scan</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize a hash scanner. </p>
<p>Reset the hash scanner so that the next element retrieved by <a class="el" href="hash_8c.html#a71535648d50cdb2b93d1d47eeb4fb872" title="Retrieve the next node from the hash table, and update the pointer for the next invocation of hash_sc...">hash_scan_next()</a> shall be the first element on the first non-empty chain.</p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>Locate the first non empty chain.</li>
<li>If an empty chain is found, remember which one it is and set the next pointer to refer to its first element.</li>
<li>Otherwise if a chain is not found, set the next pointer to NULL so that <a class="el" href="hash_8c.html#a71535648d50cdb2b93d1d47eeb4fb872" title="Retrieve the next node from the hash table, and update the pointer for the next invocation of hash_sc...">hash_scan_next()</a> shall indicate failure. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a8bdfb6df29d592b81e39b5b1703c3c58" name="a8bdfb6df29d592b81e39b5b1703c3c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bdfb6df29d592b81e39b5b1703c3c58">&#9670;&#160;</a></span>hash_scan_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhnode__t.html">hnode_t</a> * hash_scan_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhnode__t.html">hnode_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exactly like hash_delete, except does not trigger table shrinkage. This is to be used from within a hash table scan operation. See notes for hash_delete. </p>

</div>
</div>
<a id="a2e40134f24f3037e73368f7e3b78083e" name="a2e40134f24f3037e73368f7e3b78083e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e40134f24f3037e73368f7e3b78083e">&#9670;&#160;</a></span>hash_scan_delfree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_scan_delfree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhnode__t.html">hnode_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like hash_delete_free but based on hash_scan_delete. </p>

</div>
</div>
<a id="ad4bb2a56407807bb7a0fff4d90c13d47" name="ad4bb2a56407807bb7a0fff4d90c13d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bb2a56407807bb7a0fff4d90c13d47">&#9670;&#160;</a></span>hash_scan_next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhnode__t.html">hnode_t</a> * hash_scan_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhscan__t.html">hscan_t</a> *</td>          <td class="paramname"><span class="paramname"><em>scan</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the next node from the hash table, and update the pointer for the next invocation of <a class="el" href="hash_8c.html#a71535648d50cdb2b93d1d47eeb4fb872" title="Retrieve the next node from the hash table, and update the pointer for the next invocation of hash_sc...">hash_scan_next()</a>. </p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>Remember the next pointer in a temporary value so that it can be returned.</li>
<li>This assertion essentially checks whether the module has been properly initialized. The first point of interaction with the module should be either <a class="el" href="hash_8c.html#afe991e20cf1520635e01b0fae9a27986" title="Create a dynamic hash table.">hash_create()</a> or <a class="el" href="#a6064585d780b6c320f4342c917b1380f">hash_init()</a>, both of which set hash_val_t_bit to a non zero value.</li>
<li>If the next pointer we are returning is not NULL, then the user is allowed to call <a class="el" href="hash_8c.html#a71535648d50cdb2b93d1d47eeb4fb872" title="Retrieve the next node from the hash table, and update the pointer for the next invocation of hash_sc...">hash_scan_next()</a> again. We prepare the new next pointer for that call right now. That way the user is allowed to delete the node we are about to return, since we will no longer be needing it to locate the next node.</li>
<li>If there is a next node in the chain (next-&gt;next), then that becomes the new next node, otherwise ...</li>
<li>We have exhausted the current chain, and must locate the next subsequent non-empty chain in the table.</li>
<li>If a non-empty chain is found, the first element of that chain becomes the new next node. Otherwise there is no new next node and we set the pointer to NULL so that the next time <a class="el" href="hash_8c.html#a71535648d50cdb2b93d1d47eeb4fb872" title="Retrieve the next node from the hash table, and update the pointer for the next invocation of hash_sc...">hash_scan_next()</a> is called, a null pointer shall be immediately returned. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a1203f51c651d3399b5e18876a4e7a1d1" name="a1203f51c651d3399b5e18876a4e7a1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1203f51c651d3399b5e18876a4e7a1d1">&#9670;&#160;</a></span>hash_set_allocator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hash_set_allocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="include_2atalk_2hash_8h.html#aa15898e7f6a029e6d8f7aca3e93efe09">hnode_alloc_t</a></td>          <td class="paramname"><span class="paramname"><em>al</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="include_2atalk_2hash_8h.html#a8adb2eee3d269765dafe4d132d1508ae">hnode_free_t</a></td>          <td class="paramname"><span class="paramname"><em>fr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Select a different set of node allocator routines. </p>

</div>
</div>
<a id="a18b46dffd48fa70bf6a6a107988720cb" name="a18b46dffd48fa70bf6a6a107988720cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b46dffd48fa70bf6a6a107988720cb">&#9670;&#160;</a></span>hash_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2atalk_2hash_8h.html#aecc5473199dcc266fd5174f30f64a580">hashcount_t</a> hash_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d2a68020dd6bd10ea5ba593f747d22e" name="a3d2a68020dd6bd10ea5ba593f747d22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2a68020dd6bd10ea5ba593f747d22e">&#9670;&#160;</a></span>hash_verify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hash_verify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__t.html">hash_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hash</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify whether the given object is a valid hash table. </p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>If the hash table is dynamic, verify whether the high and low expansion/shrinkage thresholds are powers of two.</li>
<li>Count all nodes in the table, and test each hash value to see whether it is correct for the node's chain. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a9d481e3f3a6590f5b8024f1651aaade9" name="a9d481e3f3a6590f5b8024f1651aaade9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d481e3f3a6590f5b8024f1651aaade9">&#9670;&#160;</a></span>hnode_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhnode__t.html">hnode_t</a> * hnode_create </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab12306327a8f919b8a3c1747795f1197" name="ab12306327a8f919b8a3c1747795f1197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12306327a8f919b8a3c1747795f1197">&#9670;&#160;</a></span>hnode_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hnode_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhnode__t.html">hnode_t</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a690258e79608f3ff1799f0676c4b4395" name="a690258e79608f3ff1799f0676c4b4395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690258e79608f3ff1799f0676c4b4395">&#9670;&#160;</a></span>hnode_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * hnode_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhnode__t.html">hnode_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a65e3d96131650bbd7770fc9c6147cf12" name="a65e3d96131650bbd7770fc9c6147cf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e3d96131650bbd7770fc9c6147cf12">&#9670;&#160;</a></span>hnode_getkey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void * hnode_getkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhnode__t.html">hnode_t</a> *</td>          <td class="paramname"><span class="paramname"><em>node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaafa54bec0810daa790e9c675b667bec" name="aaafa54bec0810daa790e9c675b667bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafa54bec0810daa790e9c675b667bec">&#9670;&#160;</a></span>hnode_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhnode__t.html">hnode_t</a> * hnode_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhnode__t.html">hnode_t</a> *</td>          <td class="paramname"><span class="paramname"><em>hnode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize a client-supplied node </p>

</div>
</div>
<a id="ae4a1492b158a319cc1849e1ef8a816b4" name="ae4a1492b158a319cc1849e1ef8a816b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a1492b158a319cc1849e1ef8a816b4">&#9670;&#160;</a></span>hnode_put()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hnode_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhnode__t.html">hnode_t</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.14.0-->
<!-- modified for netatalk -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_34c6163d67acbbcfc56107279c411fb1.html">etc</a></li><li class="navelem"><a href="dir_785339ec9791c4184a005bb62f1723d7.html">afpd</a></li><li class="navelem"><a href="etc_2afpd_2hash_8h.html">hash.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
