<!-- HTML header for doxygen 1.14.0-->
<!-- modified for netatalk -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>netatalk: Directory Cache Optimization</title>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<script
    src="https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js"
    integrity="sha384-o+g/BxPwhi0C3RK7oQBxQuNimeafQ3GE/ST4iT2BxVI4Wzt60SH4pq9iXVYujjaS"
    crossorigin="anonymous"
></script>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectrow">
    <div id="projectlogo">
      <a href="/"><img alt="Logo" src="logo.png"/></a>
    </div>
    <div id="projectalign">
      <div id="projectname">
        netatalk
        <span id="projectnumber">&#160;4.4.1</span>
      </div>
      <div id="projectbrief">Free and Open Source Apple Filing Protocol (AFP) Server</div>
    </div>
  </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_developer_2dircache.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Directory Cache Optimization </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md9"></a></p>
<p><em>The Hidden Cost of Validation: How Netatalk's Directory Cache Optimization Reduces Storage Stack Pressure</em></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md10"></a>
Introduction: The Invisible Performance Tax</h1>
<p>When you access a file on a network share, you're triggering a cascade of operations through multiple cache layers. Each layer tries to optimize performance, but they can work against each other in surprising ways. This article explores how Netatalk's probabilistic directory cache validation reduces I/O by working with the storage page cache.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md12"></a>
Part 1: The Storage Stack</h1>
<p>Modern file servers orchestrate multiple cache layers, each with its own purpose and behavior:</p>
<pre class="mermaid">
graph TB
    subgraph "Application Layer"
        AFP[AFP Client Request]
        NT[Netatalk Server]
        DC[Directory Cache<br  />
LRU]
        CNID[CNID Database]
    end

    subgraph "Kernel Layer"
        PC[Page Cache<br  />
LRU]
        VFS[VFS Layer]
    end

    subgraph "Storage Layer"
        FS[Filesystem<br  />
ZFS/ext4/XFS]
        ARC[ZFS ARC Cache<br  />
Optional]
        DISK[Physical Storage]
    end

    AFP --&gt; NT
    NT --&gt; DC
    DC --&gt; CNID
    NT --&gt; VFS
    VFS --&gt; PC
    PC --&gt; FS
    FS --&gt; ARC
    ARC --&gt; DISK

    style PC fill:#ffcccc
    style DC fill:#ccffcc
    style ARC fill:#ffcccc
</pre><p>Each cache layer uses an <b>LRU (Least Recently Used)</b> algorithm to decide what to keep in memory (ZFS uses ARC instead of LRU). This works well when access patterns match LRU assumptions, but breaks down with certain workloads (especially scan workloads)—and that's where our story begins.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md14"></a>
Part 2: The Page Cache Problem</h1>
<p>The Linux page cache is incredibly fast and nearly invisible. It automatically caches file data and metadata in RAM, but here's the catch: <b>you can't directly control what stays in cache</b>.</p>
<p>LRU Performance Issues:</p>
<p>Degeneration Under Common Patterns: LRU can perform poorly with certain access patterns. For example, if an application loops over an array larger than the number of pages in the cache, it will cause a page fault for every access, leading to inefficiency (the cache churns and does not hold data long enough to achieve a good hit rate). Netatalk currently has a small maximum dircache value (dircachesize = 131072) as the implementation performance degrades above this limit.</p>
<p>Cache Pollution: LRU may evict pages that are frequently accessed but not necessarily the most relevant, which can lead to less optimal cache performance. For example when enumerating paths to move around a directory tree, Netatalk historically (and still does today by default, until you apply the new <span class="tt">afp.conf</span> tuning options shown below) performed an IO stat operation every time it reads a dircache entry to validate the file/directory still exists. These IO stat validations allow Netatalk to detect external filesystem changes, but keep unneeded data warm in the page cache, pushing other more important objects off the page cache and increasing disk IO - even though Netatalk has the dircache containing everything needed.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md15"></a>
How Directory Enumeration Works</h2>
<p>When a client browses a Netatalk network folder, here's the actual sequence:</p>
<pre class="mermaid">
sequenceDiagram
    participant Client as Mac Client
    participant Netatalk
    participant Disk as Filesystem
    participant PageCache as Page Cache
    participant DirCache as Directory Cache

    Client-&gt;&gt;Netatalk: List folder contents (FPEnumerate)
    Netatalk-&gt;&gt;Disk: readdir() - get entry names
    Disk-&gt;&gt;Netatalk: Return entry names

    loop For EACH entry
        Netatalk-&gt;&gt;PageCache: stat() each entry
        alt Cache miss
            PageCache-&gt;&gt;Disk: Read inode metadata
            Disk-&gt;&gt;PageCache: Load metadata
            Note over PageCache: Evicts LRU data
        end
        PageCache-&gt;&gt;Netatalk: Return stat data

        alt Entry is directory
            Netatalk-&gt;&gt;DirCache: Check if cached
            alt Not in cache
                Netatalk-&gt;&gt;DirCache: Add directory to cache
            end
        else Entry is file
            Netatalk-&gt;&gt;DirCache: Check if cached (if file caching enabled)
            alt Not in cache
                Netatalk-&gt;&gt;DirCache: Add file to cache (if enabled)
            end
        end
    end

    Netatalk-&gt;&gt;Client: Return file list with metadata
</pre><p><b>Key insights from <a class="el" href="enumerate_8c.html">enumerate.c</a></b>:</p>
<ol type="1">
<li>All entries are read from filesystem via <span class="tt">readdir()</span> and <span class="tt">stat()</span> all - high page-cache/disk demand</li>
<li><b>Directories</b>: Cache checked before adding, avoiding duplicate entries</li>
<li><b>Files</b>: Cache is NOT checked during enumeration - always processed via <span class="tt"><a class="el" href="afpd_2file_8c.html#a4f40897ee367f9ee8bb97e951e20d6a4">getfilparams()</a></span> which may add them to cache internally</li>
</ol>
<p><b>Current enumeration inefficiency:</b></p>
<ul>
<li><b>Every file</b> is <span class="tt">stat()</span>'ed on every enumeration</li>
<li><b>Every directory</b> is <span class="tt">stat()</span>'ed, then cache is checked to avoid duplicate entries</li>
<li>Repeatedly browsing a folder with 10,000 files = 10,000 stat calls each time (LRU scanning problem)</li>
</ul>
<p><b>Future optimization opportunity - Cache-First Enumeration:</b></p>
<p>Optimal approach:</p>
<ol type="1">
<li><b>readdir()</b>: Get list of entry names from filesystem (unavoidable - must know what exists)</li>
<li><b>For each entry</b>: Check <span class="tt"><a class="el" href="dircache_8c.html#a0754cbe312bb4c8051af6bb0cd20ff3f" title="Search the cache via did/name hashtable.">dircache_search_by_name()</a></span> first<ul>
<li><b>Cache HIT</b>: Use cached metadata</li>
<li><b>Cache MISS</b>: Fall back to <span class="tt">stat()</span> and add to cache</li>
</ul>
</li>
<li><b>Result</b>: Second enumeration of same folder could be ~99% cache-served (only 1% stat for probabilistic validation)</li>
</ol>
<p>Would potentially transform repeated directory browsing from O(n) stat calls to O(n/100) stat calls, eliminating most filesystem I/O.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md16"></a>
The LRU Scanning Problem</h2>
<p>LRU caches have a fundamental weakness called the <b>scanning problem</b>:</p>
<p>When Netatalk validates thousands of entries, each <span class="tt">stat()</span> call:</p>
<ol type="1">
<li>Checks the page cache</li>
<li>Can causes a cache miss (directories and directory trees have many entries)</li>
<li>Loads the inode from disk / or reads from page cache (either adds to page cache or refreshes timer to keep in page cache)</li>
<li><b>Evicts something potentially more valuable</b></li>
</ol>
<p>Parent folder recursion:</p>
<p>Each directory entry, stores its parent ID, and each parent ID has its own directory cache entry, providing a recursive chain (path) to root. When a new directory is accessed/added, <a class="el" href="directory_8c.html#a1d42d13b8257907a411a2704e37dfe93" title="Public CNID (Directory ID) resolution (supports files and directories).">dirlookup()</a> recursively calls itself until it finds a cached ancestor or reaches volume root. Every recursive lookup also results in many more stat calls. So even opening a small folder directly, still requires stat'ing every level of the whole path to be pushed into the page cache.</p>
<p>If the dircache max size is small (by default just 8192 entries), as you move around your file share, old entries are pushed off (evicted) as new ones are added. This high entry rotation is known as "scan eviction" and means by the time you want to go back to a previous directory and read a cached entry, it has likely already been evicted which can cause a cascade effect of recursive lookups and stats calls to restore the broken cached paths if parent entries are evicted. So unless your whole file server has less than 8192 file and directories, it is recommended to increase the <span class="tt">dircachesize</span> value in <a href="https://netatalk.io/manual/en/afp.conf.5">afp.conf</a>.</p>
<p>Future releases will increase the maximum size of the dircache once existing performance issues are addressed. We are also considering retaining directories over files during eviction to reduce recursive path discoveries after parent folders are evicted.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md18"></a>
Part 3: Why This Goes Unnoticed</h1>
<p>The page cache operates at memory speed when it hits, making overhead hard to measure:</p>
<p>The real cost isn't the individual <span class="tt">stat()</span> calls—it's the <b>cascade effect</b>:</p>
<ul>
<li>Your working set gets evicted from page cache</li>
<li>Filesystem queries slow down</li>
<li>Application data must be re-read from disk</li>
<li>Overall system responsiveness degrades</li>
</ul>
<p>However, there is only a single Page Cache per kernel. So this new dircache change in Netatalk to validate dircache periodically means less interference with other services on the same instance.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md20"></a>
Part 4: How Files Are Found - The Lookup Hierarchy</h1>
<p>Before understanding the probabilistic solution, let's see how Netatalk finds files and the precedence between cache layers:</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md21"></a>
Initial File Discovery Flow</h2>
<pre class="mermaid">
flowchart TD
    Request[Client requests file/folder]

    Request --&gt; DC_Check{In Directory<br  />
Cache?}

    DC_Check --&gt;|Cache Hit| DC_Valid{Validate?}
    DC_Check --&gt;|Cache Miss| CNID_Query[Query CNID Database]

    DC_Valid --&gt;|Every Nth request| Validate[stat filesystem]
    DC_Valid --&gt;|Other requests| Use_Cached[Use cached entry]

    Validate --&gt;|Still valid| Use_Cached
    Validate --&gt;|Invalid| Remove_Entry[Remove from cache]

    Remove_Entry --&gt; CNID_Query

    CNID_Query --&gt;|Found| FS_Check[stat filesystem]
    CNID_Query --&gt;|Not found| Create_New[Create new CNID]

    FS_Check --&gt;|Exists| Add_Cache[Add to dircache]
    FS_Check --&gt;|Missing| Error[Return error]

    Create_New --&gt; Add_Cache
    Add_Cache --&gt; Return[Return to client]
    Use_Cached --&gt; Return

    style DC_Check fill:#e6f3ff
    style CNID_Query fill:#ffe6e6
    style FS_Check fill:#ffffe6
</pre><h2 class="doxsection"><a class="anchor" id="autotoc_md22"></a>
The Precedence Hierarchy</h2>
<pre class="mermaid">
graph TB
    subgraph "Lookup Precedence"
        L1[Directory Cache - Fastest - Memory]
        L2[CNID Database - Fast - BerkeleyDB]
        L3[Filesystem - Slow - Disk I/O]

        L1 --&gt;|Miss or Invalid| L2
        L2 --&gt;|Verify exists| L3
    end

    subgraph "Data Location"
        D1[Dircache - Paths and Metadata]
        D2[CNID - ID to Path mappings]
        D3[Page Cache - File data and inodes]
        D4[Disk - Authoritative source]
    end

    L1 -.-&gt; D1
    L2 -.-&gt; D2
    L3 -.-&gt; D3
    D3 -.-&gt; D4
</pre><h2 class="doxsection"><a class="anchor" id="autotoc_md23"></a>
Key Points</h2>
<ol type="1">
<li><b>Directory Cache</b> is checked first (fastest, in-memory)</li>
<li><b>CNID Database</b> provides persistent ID→path mappings</li>
<li><b>Filesystem</b> is the ultimate authority (via stat calls)</li>
<li><b>Page Cache</b> transparently accelerates filesystem access</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md24"></a>
Part 5: The Probabilistic Solution</h1>
<p>With the lookup hierarchy understood, here's how probabilistic validation optimizes the flow:</p>
<pre class="mermaid">
stateDiagram-v2
    [*] --&gt; CacheLookup: Directory Request

    state ValidationDecision {
        [*] --&gt; CheckCounter
        CheckCounter --&gt; IncrementCounter
        IncrementCounter --&gt; Modulo: counter % freq
        Modulo --&gt; DoValidate: == 0 (validate)
        Modulo --&gt; SkipValidate: != 0 (skip)
    }

    CacheLookup --&gt; Found: Cache Hit
    CacheLookup --&gt; NotFound: Cache Miss

    Found --&gt; ValidationDecision

    DoValidate --&gt; StatCall: Filesystem stat
    SkipValidate --&gt; TrustCache: Use cached data

    StatCall --&gt; Valid: Still exists
    StatCall --&gt; Invalid: Gone/moved

    Valid --&gt; UpdateMetadata: Refresh metadata
    Invalid --&gt; RemoveEntry: Evict from cache

    RemoveEntry --&gt; QueryCNID: Rebuild from CNID
    UpdateMetadata --&gt; ServeClient
    TrustCache --&gt; ServeClient
    NotFound --&gt; QueryCNID
    QueryCNID --&gt; ServeClient

    ServeClient --&gt; [*]: Return to client

    note right of SkipValidate: 99% take this path<br  />
No filesystem I/O
</pre><p>The key insight: <b>We don't skip the cache hierarchy, we skip the validation step</b>. Files are still properly discovered through CNID when not cached, but we avoid repeatedly verifying cached entries still exist.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md25"></a>
Configuration Example</h2>
<div class="fragment"><div class="line"># afp.conf</div>
<div class="line">dircache validation freq = 100  # Validate 1 in 100 lookups</div>
</div><!-- fragment --><p>With this setting:</p>
<ul>
<li><b>99% of stat() calls eliminated</b></li>
<li>Page cache remains focused on hot data</li>
<li>Any Invalid entries (files/dirs/paths changed outside of Netatalk) are caught and corrected on use</li>
<li>Self-healing through CNID re-query on failures</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md27"></a>
Part 6: Understanding Cache Lifetimes</h1>
<p>Different cache layers have different retention strategies:</p>
<pre class="mermaid">
graph TB
    subgraph "Netatalk Dircache"
        DC1[Entry Added]
        DC1 --&gt; DC2[LRU Queue]
        DC2 --&gt; DC3[Validated 1/N times]
        DC3 --&gt; DC4[LRU Evicted when full]
    end
</pre><pre class="mermaid">
graph TB
    subgraph "Page Cache"
        PC1[Page Loaded]
        PC1 --&gt; PC2[Active List]
        PC2 --&gt; PC3[Inactive List]
        PC3 --&gt; PC4[LRU Reclaimed under pressure]
    end
</pre><pre class="mermaid">
graph TB
    subgraph "ZFS ARC"
        ARC1[Block Cached]
        ARC1 --&gt; ARC2[MRU List]
        ARC2 --&gt; ARC3[MFU List]
        ARC3 --&gt; ARC4[Ghost Lists]
        ARC4 --&gt; ARC5[ARC Evicted by ARC sizing]
    end
</pre><p>By trusting and reducing validation calls at the fastest layer (dircache), we reduce pressure on the subsequent cache layers:</p>
<ul>
<li><b>Dircache</b>: Keeps frequently accessed directory entries</li>
<li><b>Page Cache</b>: Retains genuinely hot data</li>
<li><b>ZFS ARC</b>: Maintains frequently/recently used blocks</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md29"></a>
Part 7: Monitoring the Improvement</h1>
<p>You can observe the benefits of dircache validation optimization using these metrics:</p>
<ul>
<li><b>Dircache statistics via logs</b>: Monitor <span class="tt">invalid_on_use</span> counter (should be low, indicating cached entries remain valid)</li>
<li><b>vmstat page cache activity</b>: Look for lower page scan rates (less cache churn)</li>
<li><b>iostat disk IOPS</b>: Measure reduced read IOPS (fewer stat calls to disk)</li>
<li><b>ZFS ARC stats</b>: Check for higher hit ratios (more efficient cache utilization)</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md30"></a>
Sample Statistics</h2>
<p>The actual log format from <a class="el" href="dircache_8c.html" title="Directory Cache.">dircache.c</a>:</p>
<div class="fragment"><div class="line"><a class="code hl_variable" href="dircache_8c.html#aaa0f09990ad04686c3d9dbe7d4238214">dircache</a> statistics: (user: john)</div>
<div class="line">entries: 4096, max_entries: 8192, config_max: 131072,</div>
<div class="line">lookups: 100000, hits: 95000 (95.0%), misses: 5000,</div>
<div class="line">validations: ~950 (1.0%),</div>
<div class="line">added: 5000, removed: 900, expunged: 10, invalid_on_use: 2, evicted: 256,</div>
<div class="line">validation_freq: 100</div>
<div class="ttc" id="adircache_8c_html_aaa0f09990ad04686c3d9dbe7d4238214"><div class="ttname"><a href="dircache_8c.html#aaa0f09990ad04686c3d9dbe7d4238214">dircache</a></div><div class="ttdeci">static hash_t * dircache</div><div class="ttdef"><b>Definition</b> dircache.c:114</div></div>
</div><!-- fragment --><p><b>Key metrics to monitor:</b></p>
<ul>
<li><b>invalid_on_use</b>: Should remain low - indicates cached entries stay valid</li>
<li><b>validations ratio</b>: Shows validation frequency working as configured (1.0% = every 100th)</li>
<li><b>hit_ratio</b>: High percentage (95%) indicates good cache effectiveness</li>
<li><b>max_entries</b>: Peak/high-water cache usage this session - helps tune <span class="tt">dircachesize</span></li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md32"></a>
Conclusion</h1>
<p>The real benefit of this optimization isn't just the eliminated stat() calls— it's the compound effect across the entire storage stack:</p>
<p>By understanding how cache layers interact and compete, we can make intelligent optimizations that benefit the entire system. The probabilistic validation approach shows that sometimes the best optimization isn't doing something faster— it's not doing it at all.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md33"></a>
Key Takeaways</h2>
<ol type="1">
<li><b>Page cache pollution is invisible but expensive</b></li>
<li><b>LRU caches suffer from scanning patterns</b></li>
<li><b>Probabilistic validation maintains correctness while improving performance</b></li>
<li><b>Reducing I/O helps every layer of the storage stack</b></li>
<li><b>Small changes can have compound effects</b></li>
</ol>
<p><b>By default nothing changes, as the default value for <span class="tt"><a class="el" href="dircache_8c.html#aaa0f09990ad04686c3d9dbe7d4238214">dircache</a> validation freq = 1</span>.</b></p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md34"></a>
File Caching Implementation</h2>
<p>In <a class="el" href="directory_8c.html">directory.c</a>, the <span class="tt"><a class="el" href="directory_8c.html#ade6b789ccd7cc475e656d2593fc1f398" title="Internal CNID (Directory ID) resolution with retry control.">dirlookup_internal()</a></span> function controls file caching behavior through the <span class="tt">AFPobj-&gt;options.dircache_files</span> configuration setting:</p>
<ul>
<li><b>Cache lookup</b>: When a file is found in cache, checks <span class="tt">AFPobj-&gt;options.dircache_files</span> before returning it — if disabled, returns AFPERR_BADTYPE to reject the cached file entry</li>
<li><b>CNID lookup</b>: When a file is resolved via CNID, sets the <span class="tt"><a class="el" href="include_2atalk_2directory_8h.html#a776c5eec29fd96623e3f147c34e19f51">DIRF_ISFILE</a></span> flag which will cause cache rejection if file caching is disabled</li>
<li><b>Parent recursion</b>: Uses <span class="tt">strict</span> parameter to control whether parents must be directories, ensuring parent-chain rebuilds work correctly (database design guarantee)</li>
</ul>
<p>This configuration-driven control separates caching policy from core lookup logic, allowing administrators to tune memory vs. performance tradeoffs based on workload characteristics.</p>
<hr  />
<p><em>Directory cache optimizations available in Netatalk 4.4+ with configurable validation frequency and file caching control via <span class="tt"><a class="el" href="dircache_8c.html#aaa0f09990ad04686c3d9dbe7d4238214">dircache</a> validation freq</span> and <span class="tt"><a class="el" href="dircache_8c.html#aaa0f09990ad04686c3d9dbe7d4238214">dircache</a> files</span> parameters.</em></p>
<p>Developed and Authored by Andy Lemin, with Contributions from the Netatalk team. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.14.0-->
<!-- modified for netatalk -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1 </li>
  </ul>
</div>
</body>
</html>
