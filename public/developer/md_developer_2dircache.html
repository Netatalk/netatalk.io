<!-- HTML header for doxygen 1.14.0-->
<!-- modified for netatalk -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>netatalk: DirCache redundant stat ops</title>
<link rel="icon" href="favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<script
    src="https://cdn.jsdelivr.net/npm/mermaid@11.12.0/dist/mermaid.min.js"
    integrity="o+g/BxPwhi0C3RK7oQBxQuNimeafQ3GE/ST4iT2BxVI4Wzt60SH4pq9iXVYujjaS"
    crossorigin="anonymous"
></script>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
  <div id="projectrow">
    <div id="projectlogo">
      <a href="/"><img alt="Logo" src="logo.png"/></a>
    </div>
    <div id="projectalign">
      <div id="projectname">
        netatalk
        <span id="projectnumber">&#160;4.4.0dev</span>
      </div>
      <div id="projectbrief">Free and Open Source Apple Filing Protocol (AFP) Server</div>
    </div>
  </div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_developer_2dircache.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">DirCache redundant stat ops </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md15"></a></p>
<p>The Hidden Cost of Validation: How Netatalk's Directory Cache Optimization Reduces Storage Stack Pressure</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md16"></a>
Introduction: The Invisible Performance Tax</h1>
<p>When you access a file on a network share, you're triggering a cascade of operations through multiple cache layers. Each layer tries to optimize performance, but they can work against each other in surprising ways. This article explores how Netatalk's probabilistic directory cache validation reduces I/O by working with the storage page cache.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md18"></a>
Part 1: The Storage Stack</h1>
<p>Modern file servers orchestrate multiple cache layers, each with its own purpose and behavior:</p>
<pre class="mermaid">
graph TB
    subgraph "Application Layer"
        AFP[AFP Client Request]
        NT[Netatalk Server]
        DC[Directory Cache<br  />
LRU]
        CNID[CNID Database]
    end

    subgraph "Kernel Layer"
        PC[Page Cache<br  />
LRU]
        VFS[VFS Layer]
    end

    subgraph "Storage Layer"
        FS[Filesystem<br  />
ZFS/ext4/XFS]
        ARC[ZFS ARC Cache<br  />
Optional]
        DISK[Physical Storage]
    end

    AFP --&gt; NT
    NT --&gt; DC
    DC --&gt; CNID
    NT --&gt; VFS
    VFS --&gt; PC
    PC --&gt; FS
    FS --&gt; ARC
    ARC --&gt; DISK

    style PC fill:#ffcccc
    style DC fill:#ccffcc
    style ARC fill:#ffcccc
</pre><p>Each cache layer uses an <b>LRU (Least Recently Used)</b> algorithm to decide what to keep in memory (ZFS uses ARC instead of LRU). This works well when access patterns match LRU assumptions, but breaks down with certain workloads (especially scan workloads)—and that's where our story begins.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md20"></a>
Part 2: The Page Cache Problem</h1>
<p>The Linux page cache is incredibly fast and nearly invisible. It automatically caches file data and metadata in RAM, but here's the catch: <b>you can't directly control what stays in cache</b>.</p>
<p>LRU Performance Issues:</p>
<p>Degeneration Under Common Patterns: LRU can perform poorly with certain access patterns. For example, if an application loops over an array larger than the number of pages in the cache, it will cause a page fault for every access, leading to inefficiency (the cache churns and does not hold data long enough to achieve a good hit rate). Netatalk currently has a small maximum dircache value (dircachesize = 131072) as the implementation performance degrades above this limit.</p>
<p>Cache Pollution: LRU may evict pages that are frequently accessed but not necessarily the most relevant, which can lead to less optimal cache performance. For example when enumerating paths to move around a directory tree, Netatalk historically (and still does today by default, until you apply the new <span class="tt">afp.conf</span> tuning options shown below) performed an IO stat operation every time it reads a dircache entry to validate the file/directory still exists. These IO stat validations allow Netatalk to detect external filesystem changes, but keep unneeded data warm in the page cache, pushing other more important objects off the page cache and increasing disk IO - even though Netatalk has the dircache containing everything needed.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md21"></a>
How Directory Enumeration Pollutes the Page Cache</h2>
<p>When a client browses a Netatalk network folder, here's what traditionally happens:</p>
<pre class="mermaid">
sequenceDiagram
    participant Client as Mac Client
    participant Netatalk
    participant DirCache as Directory Cache
    participant PageCache as Page Cache
    participant Disk as Storage

    Client-&gt;&gt;Netatalk: List folder contents
    Netatalk-&gt;&gt;DirCache: Lookup entries

    loop For EVERY cached entry
        DirCache-&gt;&gt;Netatalk: Return cached entry
        Note over Netatalk: Must validate freshness
        Netatalk-&gt;&gt;PageCache: stat() system call
        alt Cache miss
            PageCache-&gt;&gt;Disk: Read inode
            Disk-&gt;&gt;PageCache: Load metadata
            Note over PageCache: Page-Cache Evicts something else!
        end
        PageCache-&gt;&gt;Netatalk: Store and Return metadata
    end

    Netatalk-&gt;&gt;Client: Return validated list
</pre><p>With the dircache improvements we no longer run everything inside "[For EVERY cached entry]". Instead we now only do this probabilistically, and transparently when a cached entry is found to be invalid on use.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md22"></a>
The LRU Scanning Problem</h2>
<p>LRU caches have a fundamental weakness called the <b>scanning problem</b>:</p>
<p>When Netatalk validates thousands of directory entries, each <span class="tt">stat()</span> call:</p>
<ol type="1">
<li>Checks the page cache</li>
<li>Can causes a cache miss (directories and directory trees have many entries)</li>
<li>Loads the inode from disk / or reads from page cache (either adds to page cache or refreshes timer to keep in page cache)</li>
<li><b>Evicts something potentially more valuable</b></li>
</ol>
<p>Parent folder recursion:</p>
<p>Each directory entry, stores its parent ID, and each parent ID has its own directory cache entry, providing a recursive chain (path) to root. When a new directory is accessed/added, <a class="el" href="directory_8c.html#a1d42d13b8257907a411a2704e37dfe93" title="Resolve a DID.">dirlookup()</a> recursively calls itself until it finds a cached ancestor or reaches volume root. Every recursive lookup also results in many more stat calls. So even opening a small folder directly, still requires stat'ing every level of the whole path to be pushed into the page cache.</p>
<p>If the dircache max size is small (by default just 8192 entries), as you move around your file share, old entries are pushed off (evicted) as new ones are added. This high entry rotation is known as "scan eviction" and means by the time you want to go back to a previous directory and read a cached entry, it has likely already been evicted which can cause a cascade effect of recursive lookups and stats calls to restore the broken cached paths if parent entries are evicted. So unless your whole file server has less than 8192 file and directories, it is recommended to increase the <span class="tt">dircachesize</span> value in <a href="https://netatalk.io/manual/en/afp.conf.5">afp.conf</a>.</p>
<p>Future releases will increase the maximum size of the dircache once existing performance issues are addressed. We are also considering retaining directories over files during eviction to reduce recursive path discoveries after parent folders are evicted.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md24"></a>
Part 3: Why This Goes Unnoticed</h1>
<p>The page cache operates at memory speed when it hits, making overhead hard to measure:</p>
<p>The real cost isn't the individual <span class="tt">stat()</span> calls—it's the <b>cascade effect</b>:</p>
<ul>
<li>Your working set gets evicted from page cache</li>
<li>Filesystem queries slow down</li>
<li>Application data must be re-read from disk</li>
<li>Overall system responsiveness degrades</li>
</ul>
<p>However, there is only a single Page Cache per kernel. So this new dircache change in Netatalk to validate dircache periodically means less interference with other services on the same instance.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md26"></a>
Part 4: How Files Are Found - The Lookup Hierarchy</h1>
<p>Before understanding the probabilistic solution, let's see how Netatalk finds files and the precedence between cache layers:</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md27"></a>
Initial File Discovery Flow</h2>
<pre class="mermaid">
flowchart TD
    Request[Client requests file/folder]

    Request --&gt; DC_Check{In Directory<br  />
Cache?}

    DC_Check --&gt;|Cache Hit| DC_Valid{Validate?}
    DC_Check --&gt;|Cache Miss| CNID_Query[Query CNID Database]

    DC_Valid --&gt;|Every Nth request| Validate[stat filesystem]
    DC_Valid --&gt;|Other requests| Use_Cached[Use cached entry]

    Validate --&gt;|Still valid| Use_Cached
    Validate --&gt;|Invalid| Remove_Entry[Remove from cache]

    Remove_Entry --&gt; CNID_Query

    CNID_Query --&gt;|Found| FS_Check[stat filesystem]
    CNID_Query --&gt;|Not found| Create_New[Create new CNID]

    FS_Check --&gt;|Exists| Add_Cache[Add to dircache]
    FS_Check --&gt;|Missing| Error[Return error]

    Create_New --&gt; Add_Cache
    Add_Cache --&gt; Return[Return to client]
    Use_Cached --&gt; Return

    style DC_Check fill:#e6f3ff
    style CNID_Query fill:#ffe6e6
    style FS_Check fill:#ffffe6
</pre><h2 class="doxsection"><a class="anchor" id="autotoc_md28"></a>
The Precedence Hierarchy</h2>
<pre class="mermaid">
graph TB
    subgraph "Lookup Precedence"
        L1[Directory Cache - Fastest - Memory]
        L2[CNID Database - Fast - BerkeleyDB]
        L3[Filesystem - Slow - Disk I/O]

        L1 --&gt;|Miss or Invalid| L2
        L2 --&gt;|Verify exists| L3
    end

    subgraph "Data Location"
        D1[Dircache - Paths and Metadata]
        D2[CNID - ID to Path mappings]
        D3[Page Cache - File data and inodes]
        D4[Disk - Authoritative source]
    end

    L1 -.-&gt; D1
    L2 -.-&gt; D2
    L3 -.-&gt; D3
    D3 -.-&gt; D4
</pre><h2 class="doxsection"><a class="anchor" id="autotoc_md29"></a>
Key Points</h2>
<ol type="1">
<li><b>Directory Cache</b> is checked first (fastest, in-memory)</li>
<li><b>CNID Database</b> provides persistent ID→path mappings</li>
<li><b>Filesystem</b> is the ultimate authority (via stat calls)</li>
<li><b>Page Cache</b> transparently accelerates filesystem access</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md30"></a>
Part 5: The Probabilistic Solution</h1>
<p>With the lookup hierarchy understood, here's how probabilistic validation optimizes the flow:</p>
<pre class="mermaid">
stateDiagram-v2
    [*] --&gt; CacheLookup: Directory Request

    state ValidationDecision {
        [*] --&gt; CheckCounter
        CheckCounter --&gt; IncrementCounter
        IncrementCounter --&gt; Modulo: counter % freq
        Modulo --&gt; DoValidate: == 0 (validate)
        Modulo --&gt; SkipValidate: != 0 (skip)
    }

    CacheLookup --&gt; Found: Cache Hit
    CacheLookup --&gt; NotFound: Cache Miss

    Found --&gt; ValidationDecision

    DoValidate --&gt; StatCall: Filesystem stat
    SkipValidate --&gt; TrustCache: Use cached data

    StatCall --&gt; Valid: Still exists
    StatCall --&gt; Invalid: Gone/moved

    Valid --&gt; UpdateMetadata: Refresh metadata
    Invalid --&gt; RemoveEntry: Evict from cache

    RemoveEntry --&gt; QueryCNID: Rebuild from CNID
    UpdateMetadata --&gt; ServeClient
    TrustCache --&gt; ServeClient
    NotFound --&gt; QueryCNID
    QueryCNID --&gt; ServeClient

    ServeClient --&gt; [*]: Return to client

    note right of SkipValidate: 99% take this path<br  />
No filesystem I/O
</pre><p>The key insight: <b>We don't skip the cache hierarchy, we skip the validation step</b>. Files are still properly discovered through CNID when not cached, but we avoid repeatedly verifying cached entries still exist.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md31"></a>
Configuration Example</h2>
<div class="fragment"><div class="line"># afp.conf</div>
<div class="line">dircache validation freq = 100  # Validate 1 in 100 lookups</div>
</div><!-- fragment --><p>With this setting:</p>
<ul>
<li><b>99% of stat() calls eliminated</b></li>
<li>Page cache remains focused on hot data</li>
<li>Any Invalid entries (files/dirs/paths changed outside of Netatalk) are caught and corrected on use</li>
<li>Self-healing through CNID re-query on failures</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md33"></a>
Part 6: Understanding Cache Lifetimes</h1>
<p>Different cache layers have different retention strategies:</p>
<pre class="mermaid">
graph TB
    subgraph "Netatalk Dircache"
        DC1[Entry Added]
        DC1 --&gt; DC2[LRU Queue]
        DC2 --&gt; DC3[Validated 1/N times]
        DC3 --&gt; DC4[LRU Evicted when full]
    end
</pre><pre class="mermaid">
graph TB
    subgraph "Page Cache"
        PC1[Page Loaded]
        PC1 --&gt; PC2[Active List]
        PC2 --&gt; PC3[Inactive List]
        PC3 --&gt; PC4[LRU Reclaimed under pressure]
    end
</pre><pre class="mermaid">
graph TB
    subgraph "ZFS ARC"
        ARC1[Block Cached]
        ARC1 --&gt; ARC2[MRU List]
        ARC2 --&gt; ARC3[MFU List]
        ARC3 --&gt; ARC4[Ghost Lists]
        ARC4 --&gt; ARC5[ARC Evicted by ARC sizing]
    end
</pre><p>By trusting and reducing validation calls at the fastest layer (dircache), we reduce pressure on the subsequent cache layers:</p>
<ul>
<li><b>Dircache</b>: Keeps frequently accessed directory entries</li>
<li><b>Page Cache</b>: Retains genuinely hot data</li>
<li><b>ZFS ARC</b>: Maintains frequently/recently used blocks</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md35"></a>
Part 7: Monitoring the Improvement</h1>
<p>You can observe the benefits using these metrics:</p>
<pre class="mermaid">
graph LR
    subgraph "Metrics to Watch"
        M1[dircache statistics<br  />
via logs]
        M2[vmstat<br  />
page cache activity]
        M3[iostat<br  />
disk IOPS]
        M4[ZFS ARC stats<br  />
hit rates]
    end

    M1 --&gt; R1[invalid_on_use<br  />
should be low]
    M2 --&gt; R2[Lower scan rate]
    M3 --&gt; R3[Reduced read IOPS]
    M4 --&gt; R4[Higher hit ratio]

    style R1 fill:#e6f3ff
    style R2 fill:#e6f3ff
    style R3 fill:#e6f3ff
    style R4 fill:#e6f3ff
</pre><h2 class="doxsection"><a class="anchor" id="autotoc_md36"></a>
Sample Statistics</h2>
<div class="fragment"><div class="line"><a class="code hl_variable" href="dircache_8c.html#aaa0f09990ad04686c3d9dbe7d4238214">dircache</a> statistics: (user: john)</div>
<div class="line">entries: 4096, lookups: 100000, </div>
<div class="line">hits: 95000 (95.0%), misses: 5000,</div>
<div class="line">validations: ~950 (1.0%),  # ← Only 1% validated!</div>
<div class="line">added: 5000, removed: 900, </div>
<div class="line">expunged: 10, invalid_on_use: 2, </div>
<div class="ttc" id="adircache_8c_html_aaa0f09990ad04686c3d9dbe7d4238214"><div class="ttname"><a href="dircache_8c.html#aaa0f09990ad04686c3d9dbe7d4238214">dircache</a></div><div class="ttdeci">static hash_t * dircache</div><div class="ttdef"><b>Definition</b> dircache.c:114</div></div>
</div><!-- fragment --><hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md38"></a>
Conclusion</h1>
<p>The real benefit of this optimization isn't just the eliminated stat() calls— it's the compound effect across the entire storage stack:</p>
<p>By understanding how cache layers interact and compete, we can make intelligent optimizations that benefit the entire system. The probabilistic validation approach shows that sometimes the best optimization isn't doing something faster— it's not doing it at all.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md39"></a>
Key Takeaways</h2>
<ol type="1">
<li><b>Page cache pollution is invisible but expensive</b></li>
<li><b>LRU caches suffer from scanning patterns</b></li>
<li><b>Probabilistic validation maintains correctness while improving performance</b></li>
<li><b>Reducing I/O helps every layer of the storage stack</b></li>
<li><b>Small changes can have compound effects</b></li>
</ol>
<p><b>By default nothing changes, as the default value for <span class="tt">dircache validation freq = 1</span>.</b></p>
<p>To try this speed up, configure it;</p>
<div class="fragment"><div class="line">dircache validation freq = 1-100</div>
<div class="line">dircache metadata window = 60-3600</div>
<div class="line">dircache metadata threshold = 10-1800</div>
</div><!-- fragment --><hr  />
<p><em>This optimization is available in Netatalk 4.4+ with configurable validation frequency via the <span class="tt">dircache validation freq</span> parameter.</em></p>
<p>Developed and Authored by Andy Lemin, with Contributions from the Netatalk team. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.14.0-->
<!-- modified for netatalk -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
